## 消息填充模块

```c
sm3_hash(const uint8_t *msg, size_t msglen, uint8_t out[32])
```
实际上相当于**函数入口**
`msg`代表输入信息
`msglen`代表消息长度
`out`代表将要输出的256位的sm3杂凑值


```c
uint64_t bitlen = (uint64_t)msglen * 8ULL; // 原文 bit 长度
```
`bitlen`用于存储原文长度，`uint64_t`代表类型为64位无符号整数，因为SM3 标准规定：消息长度使用 64 位存储，不能多也不能少
`(uint64_t)msglen`用于将`msglen`显式转换为`uint64_t`类型
`msglen`代表输入消息的字节长度

```c
size_t k = (56 - (msglen + 1) % 64) % 64;
```
`k`表示需要填充的0的数量,前面说过需要填充0使得`l+1+k≡448(mod 512)`

```c
size_t padlen = 1 + k + 8;
size_t total = msglen + padlen;
```
`padlen`代表了总共需要在原来输入中添加多少字节(1字节=8位)
`total`即为输入长度+填充长度
```c
uint8_t *buf = (uint8_t *)malloc(total);
memcpy(buf, msg, msglen);
buf[msglen] = 0x80;
memset(buf + msglen + 1, 0, k);
for (int i = 0; i < 8; ++i)
{
    buf[msglen + 1 + k + i] = (uint8_t)(bitlen >> (56 - 8 * i));
}
```
buf填充的具体步骤如下:
1. 给`buf`分配总共需要的大小，用于存储填充后的完整消息
2. 将原始信息`msg`输入到`buf`中
3. 在`buf`中填充1(还要附加7个0组成一字节,但不可能越界,因为一个字符占8位)
4. 将需要填充的0填入`buf`
5. 将64位的长度信息填入`buf`,这里`buf[msglen + 1 + k + i]`是为了跳过原始信息长度`msglen`,1位填充位,`k`个填充0,最后的`+i`是每个长度信息的偏移量


## 消息扩展模块
```c
size_t blocks = total / 64;
for (size_t i = 0; i < blocks; ++i)
{
    sm3_compress(V, buf + i * 64);
}
```
将填充完毕后的信息分组,512位为1组,再让每组开始进行消息扩展

```c
void sm3_compress(uint32_t V[8], const uint8_t block[64])
```
消息扩展函数
`V`用于等会的压缩函数作为初始数值
`block`即表示当前组,每组都要进行一次扩展和压缩

接下来要将消息扩展为132个32位的W(W0, W1, ..., W67 和 W‘0, W’1, ..., W‘63)
```c
for (int j = 0; j < 16; ++j)
{
    W[j] = GETU32_BE(block + j * 4);
}
```
前16个W很简单,就是将分组中的内容平分位16块填入W0-W15

```c
for (int j = 16; j < 68; ++j)
{
    uint32_t x = W[j - 16] ^ W[j - 9] ^ ROTL(W[j - 3], 15);
    W[j] = P1(x) ^ ROTL(W[j - 13], 7) ^ W[j - 6];
}
```
该段为W16到W67用此方法扩展,其中ROTL具体为
```c
#define ROTL(x, n) (((x) << (n)) | ((x) >> (32 - (n))))
```
其中P1具体为
```c
#define P1(x) ((x) ^ ROTL((x), 15) ^ ROTL((x), 23))
```

```c
for (int j = 0; j < 64; ++j)
{
W1[j] = W[j] ^ W[j + 4];
}
```
该段为W'0 到 W'63的扩展方法,也是W比W'多4位的原因
至此消息扩展完成

## 压缩函数
初始化寄存器
```c
uint32_t A = V[0], B = V[1], C = V[2], D = V[3];
uint32_t E = V[4], F = V[5], G = V[6], H = V[7];
```
接下来的每轮压缩都会得到一个新的`ABCDEFGH`的值,直到最后一组消息分组进行完压缩,最后的`ABCDEFGH`便是消息的杂凑值

64轮迭代函数如下
```c
for (int j = 0; j < 64; ++j)
{
    uint32_t Tj = (j <= 15) ? Tj_base0 : Tj_base1; // 选择对应的 Tj
    uint32_t T_rot = ROTL(Tj, j & 31);             // Tj 循环左移 j 位
    // SS1 = ((A<<<12) + E + (Tj<<<j)) <<< 7
    uint32_t SS1 = ROTL((ROTL(A, 12) + E + T_rot), 7);
    // SS2 = SS1 ^ (A<<<12)
    uint32_t SS2 = SS1 ^ ROTL(A, 12);
    // TT1 = FF(A,B,C) + D + SS2 + W1[j]
    uint32_t TT1 = (FFj(A, B, C, j) + D + SS2 + W1[j]);
    // TT2 = GG(E,F,G) + H + SS1 + W[j]
    uint32_t TT2 = (GGj(E, F, G, j) + H + SS1 + W[j]);
    // 寄存器更新（按标准）
    D = C;
    C = ROTL(B, 9);
    B = A;
    A = TT1;
    H = G;
    G = ROTL(F, 19);
    F = E;
    E = P0(TT2);
}
```
其中,SS1,SS2,TT1,TT2都只是一个暂存的容器,
Tj是一个随着循环轮数变换的常数
具体为`Tj = 79cc4519 (前16轮) 或 7a879d8a (后48轮)`
ROTL在前文有做过解释
FFj和GGj是布尔函数,具体实现如下
```c
static inline uint32_t FFj(uint32_t x, uint32_t y, uint32_t z, int j)
{
    // 第 0~15 轮：FF = X ^ Y ^ Z
    if (j >= 0 && j <= 15)
        return x ^ y ^ z;

    // 第 16~63 轮：FF = (X & Y) | (X & Z) | (Y & Z)
    return (x & y) | (x & z) | (y & z);
}

static inline uint32_t GGj(uint32_t x, uint32_t y, uint32_t z, int j)
{
    // 第 0~15 轮：GG = X ^ Y ^ Z
    if (j >= 0 && j <= 15)
        return x ^ y ^ z;

    // 第 16~63 轮：GG = (X & Y) | ((~X) & Z)
    return (x & y) | ((~x) & z);
}
```
最后,当各个分组做完64轮迭代后,我们便可以得到新的`ABCDEFGH`,每个变量占32位共256位,这便是最终的杂凑值

## 整体接口
```c
int main(void)
{
    char input[1024];
    uint8_t digest[32];
    printf("请输入要进行 SM3 的字符串（可为空）：\n");
    sm3_hash((const uint8_t *)input, strlen(input), digest);
    printf("sm3(\"%s\") = ", input);
    print_hex(digest, 32);
    return 0;
}
```
在整体接口中,系统会提示用户 **"请输入要进行 SM3 的字符串（可为空）"** ,用户需要输入最多1023个字符(也可以不输入直接计算空字符的sm3杂凑值)

接着系统调用sm3_hash来开始计算sm3杂凑值,并将结果存储到256位的结果变量digest
最后将输出杂凑值,此接口简单易用